#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Motor,  mtr_S1_C1_1,     motor1,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motor2,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     motor3,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_2,     motor4,        tmotorTetrix, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//ROBOTC code for TETRIX + NXT 2.0 Octagonal, Omniwheel, 45 degree, 4 wheel Holonomic Chassis. 

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.


void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

  return;
}

int filterJS(short n) {
	return sgn(n)*((long)(n)*(long)(n)*25)/(4096);
}

task main()
{
  initializeRobot();

  waitForStart();   // wait for start of tele-op phase

  while (true)
  {
  		getJoystickSettings(joystick);

	  	motor[motor1] = filterJS(joystick.joy1_y1) - filterJS(joystick.joy1_x1) - filterJS(joystick.joy1_x2);
	  	motor[motor2] = filterJS(joystick.joy1_y1) + filterJS(joystick.joy1_x1) - filterJS(joystick.joy1_x2);
	  	motor[motor3] = filterJS(joystick.joy1_y1) - filterJS(joystick.joy1_x1) + filterJS(joystick.joy1_x2);
	  	motor[motor4] = filterJS(joystick.joy1_y1) + filterJS(joystick.joy1_x1) + filterJS(joystick.joy1_x2);

	  	wait1Msec(10);


  }
}
